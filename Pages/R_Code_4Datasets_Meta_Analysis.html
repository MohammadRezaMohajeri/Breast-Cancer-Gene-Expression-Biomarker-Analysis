<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>R Code For 4 Datasets (Meta-analysis)</title>
	<style>
		/* CSS Styles */
		/* To highlight different  parts of  the text in red, green, and blue, you can use the <span> element and apply CSS styles to  it */ 
		
		.orange-text {
			color: orange;
			font-weight: bold;
		}
		.dark-yellow-text {
			color: hsl(50, 100%, 30%); /* Adjust the hue and saturation values as needed */
			font-weight: bold;
		}
		.brown-text {
			color: hsl(30, 100%, 30%); /* Adjust the hue and saturation values as needed */
			font-weight: bold;
		}
		.green-text {
			color: green;
			font-weight: bold;
		}
		.purple-text {
			color: purple;
			font-weight: bold;
		}
		.blue-text {
			color: blue;
			font-weight: bold;
		}

		/* Header Styles */
		header {
			background-color: #260e02;
			color: white;
			text-align: center;
			padding: 5px;
		}

		h1 {
			color: white; /* Adjust the font color as desired */
			font-size: 30px; /* Adjust the font size as desired */
			font-weight: bold; /* Add font weight as desired */
			text-align: center; /* Center the header title */
			padding: 0px; /* Add padding around the header title */
		}
		
		hr {
			width: 100%; /* Adjust the width as desired */
		}
		
		/* Drop-down Styles */
		.drop-down-content {
			display: none;
		}

		.dropdown-trigger {
			cursor: pointer;
		}

		.drop-down-content.active {
			display: block;
		}
		
		
		h3.dropdown-trigger {
		font-size: 24px; /* Adjust the font size as desired */
		}

	        /* Adjust font size for paragraph under 1-1- Explanation:*/
		.drop-down-content p {
			font-size: 16px; /* Adjust the font size as desired */
		}

		/* Adjust font size for list items */
		.drop-down-content ul li {
			font-size: 16px; /* Adjust the font size as desired */
		}

			/* Adjust font size for the explanation paragraph */
		#explanation-content p {
			font-size: 20px; /* Adjust the font size as desired */
		}
		
		/* Adjust font size for the headings */
		#plots-tables-content ul li a {
			font-size: 20px; /* Adjust the font size as desired */
		}
		
		/* Adjust font size for the code block */
		#code-content pre code {
			font-size: 20px; /* Adjust the font size as desired */
		}
		
		/* Footer Styles */
		.footer {
		        background-color: #333;
		        color: #fff;
		        padding: 10px;
		        text-align: center;
		        position: fixed;
		        left: 0;
		        bottom: 0;
		        width: 100%;
		}
		
	</style>
	
</head>
<body>
	<header>
		<h1>R Code <br> For 4 Datasets (Meta-analysis)</h1>
	</header>
	
	
	<h2 style="font-size: 28px; text-align: center;">1- Differential Expression Analysis of Breast Cancer Dataset (GSE25055) using limma in R: Comparing Molecular Subtypes and Grading System</h2>

	
	<hr>
	<h3 class="dropdown-trigger" onclick="toggleDropDown('explanation-content')">About this code</h3>
	<div class="drop-down-content" id="explanation-content" style="text-align: justify;">
		<p>I want to have a paragraph here to explain the analysis. I want to have a paragraph here to explain the analysis. I want to have a paragraph here to explain the analysis. I want to have a paragraph here to explain the analysis. I want to have a paragraph here to explain the analysis. I want to have a paragraph here to explain the analysis.</p>
	</div>
	<hr>

	
	<h3 class="dropdown-trigger" onclick="toggleDropDown('plots-tables-content')">Generated Plots & Tables</h3>
	<div class="drop-down-content" id="plots-tables-content">
		<ul>
			<li><a href="#">Volcano plots for comparing grade 1 vs grade 3 (GSE25055 dataset)</a></li>
			<li><a href="#">Volcano plots for comparing Luminal A, Normal-like vs Luminal B, Basal-like, and HER2 (GSE25055 dataset)</a></li>
			<li><a href="#">Tables</a></li>
		</ul>
	</div>
	<hr>

	<h3 class="dropdown-trigger" onclick="toggleDropDown('code-content')">Code (<a href="https://mohammadrezamohajeri.github.io/Breast-Cancer-Gene-Expression-Biomarker-Analysis/Pages/R_Code_4Datasets_Meta_Analysis_Code_Page.html">Click to go to the code section</a>)</h3>
	<div class="drop-down-content" id="code-content">
		<pre><code>
			<!--
			<span class="green-text">GREEN TEXTTTTTT</span> 
			<span class="purple-text">PURPLE TEXTTTTTT</span> 
			<span class="orange-text">ORANGE TEXTTTT</span> 
			<span class="dark-yellow-text">DARK YELLOW TEXTTT</span> 
			<span class="brown-text">BROWN TEXTTTT</span> 
			<span class="blue-text">BLUE TEXTTTTT</span> 
			<strong>BOLD TEXTTTTTT</strong> 
			-->
################################################################# "Package Installation" #################################################################
#################################### Uncomment the following lines if any of the packages are not already installed or need to be reinstalled.############
# BiocManager packages
# Install required Bioconductor packages
# BiocManager::install("sva", force = TRUE)
# BiocManager::install("GeneMeta", force = TRUE)
# BiocManager::install("ComplexHeatmap", force = TRUE)
# BiocManager::install("fgsea", force = TRUE)
# BiocManager::install("clusterProfiler", force = TRUE)
			
# Other packages
# Install required CRAN packages:
# install.packages("RColorBrewer")
# install.packages("msigdbr")
# install.packages("ggpubr")
# install.packages("reshape2")
# install.packages("caret")
# install.packages("rgl")

# sva package installation
# Install "sva" package using BiocManager
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# BiocManager::install("sva")

# VSN package installation
# Install "vsn" package using BiocManager
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# BiocManager::install("vsn")

# tidyverse package installation
# install.packages("tidyverse")

# GEOquery package installation
# Install "GEOquery" package using BiocManager
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# BiocManager::install("GEOquery")

# limma package installation
# install.packages("limma")

# plotly package installation
# install.packages("plotly")

# ggvenn package installation
# install.packages("ggvenn")

# ggpubr package installation
# install.packages("ggpubr")

# rgl package installation
# For rgl installation, require remotes package first
# install.packages("remotes")
# require(remotes)
# remotes::install_github("dmurdoch/rgl")


# Package Loading
# Load the required packages for data analysis and visualization.
			
require(tidyverse)       <span style="color: #0000FF; font-style: italic;"># Package for comprehensive data manipulation and visualization, including dplyr, ggplot2, and other useful packages</span>
require(GEOquery)        <span style="color: #0000FF; font-style: italic;"># Package for accessing and retrieving gene expression data from the Gene Expression Omnibus (GEO) database</span>
require(reshape2)        <span style="color: #0000FF; font-style: italic;"># Package for reshaping data from wide to long format and vice versa, useful for data preprocessing</span>
require(caret)           <span style="color: #0000FF; font-style: italic;"># Package for machine learning and predictive modeling, providing a unified interface for various algorithms and performance evaluation</span>
require(GeneMeta)        <span style="color: #0000FF; font-style: italic;"># Package for meta-analysis of gene expression data, allowing combining results from multiple studies</span>
require(limma)           <span style="color: #0000FF; font-style: italic;"># Package for analyzing microarray data using linear models, including differential expression analysis</span>
require(rgl)             <span style="color: #0000FF; font-style: italic;"># Package for creating interactive 3D visualizations, useful for exploring complex data structures</span>
require(sva)             <span style="color: #0000FF; font-style: italic;"># Package for surrogate variable analysis, used to identify and adjust for unwanted variation in high-dimensional datasets</span>
require(plotly)          <span style="color: #0000FF; font-style: italic;"># Package for creating interactive and dynamic plots, including scatter plots, bar plots, and more</span>
require(ggvenn)          <span style="color: #0000FF; font-style: italic;"># Package for creating Venn diagrams using ggplot2, useful for visualizing set relationships</span>
require(ggpubr)          <span style="color: #0000FF; font-style: italic;"># Package for creating publication-ready plots using ggplot2, providing additional customization options</span>
require(ComplexHeatmap)  <span style="color: #0000FF; font-style: italic;"># Package for creating complex heatmaps, allowing visualization of multiple layers of data and annotations</span>
require(RColorBrewer)    <span style="color: #0000FF; font-style: italic;"># Package for providing color palettes suitable for data visualization</span>
require(msigdbr)         <span style="color: #0000FF; font-style: italic;"># Package for accessing and using the Molecular Signatures Database (MSigDB) for gene set enrichment analysis</span>
require(fgsea)           <span style="color: #0000FF; font-style: italic;"># Package for performing gene set enrichment analysis (GSEA) using fast gene set testing algorithms</span>
require(locfit)          <span style="color: #0000FF; font-style: italic;"># Package for local regression modeling, useful for fitting flexible curves to data</span>
require(vsn)             <span style="color: #0000FF; font-style: italic;"># Package for variance stabilization and normalization, specifically for microarray data analysis</span>


DownloadGEO <- function(GSEname = "GSE25065"){
  # Create a folder
  dir.create(GSEname, showWarnings = F)
  # Increase memory
  Sys.setenv("VROOM_CONNECTION_SIZE"=131072*10)
  #Download dataset
  gset <- getGEO(GSEname, GSEMatrix =TRUE, AnnotGPL = TRUE,
                 destdir = paste0(getwd(), "/", GSEname))
  if(!is.null(gset)){
    # Extracting matrix, phenotype, and annotation
    matrix <- gset[[paste0(GSEname, "_series_matrix.txt.gz")]]@assayData[["exprs"]]
    # Reverse log2 transformation if the matrix is transformed
    qx <- as.numeric(quantile(matrix, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
    LogC <- (qx[5] > 100) || (qx[6]-qx[1] > 50 && qx[2] > 0)
    if(!LogC){
      matrix <- 2^(matrix)
    }
    matrix <- cbind(rownames(matrix), matrix)
    colnames(matrix)[1] <- "ID"

    phenotype <- gset[[paste0(GSEname, "_series_matrix.txt.gz")]]@phenoData@data
    phenotype <- cbind(rownames(phenotype), phenotype)
    colnames(phenotype)[1] <- "ID"
    annot <- gset[[paste0(GSEname, "_series_matrix.txt.gz")]]@featureData@data
    # Writing the extracted variables
    write.csv(matrix, paste0(GSEname, "/", "matrix.csv"), quote = F, row.names = F)
    write_tsv(phenotype, paste0(GSEname, "/", "phenotype.tsv"))
    write_tsv(annot, paste0(GSEname, "/", "annot.tsv"))
    # Removing variables
    rm(gset, matrix, phenotype, annot)
    message("+++++ Datatset is ready to analyse. +++++")
  }
}

ReadGEO <- function(projname) {
  # Reading matrix file
  matrix <- read_csv(paste0(projname, "/", "matrix.csv"))
  matrix <- data.frame(matrix)
}


MakePhenotype <- function(projname, compare = "grade") {
  # Preparing the phenotype for all GSE files
  dir.create("Phenotype", showWarnings = F)
  pheno <- list()
  for(i in seq_along(projname)){
    phenotype <- read_tsv(paste0(projname[i], "/", "phenotype.tsv"))
    phenotype <- data.frame(phenotype)
    rownames(phenotype) <- phenotype[,1]
    phenotype <- phenotype[,-1]
    pheno[[projname[i]]] <- phenotype
  }
  # Choosing either subtype or grade
  if(compare == "subtype"){
    pheno2 <- list()
    for (i in seq_along(pheno)) {
      phecoln <- grep("pam50", pheno[[i]])
      if(length(phecoln) > 0) {
        pheno1 <- data.frame(pheno[[i]][ ,phecoln])
        colnames(pheno1) <- "subtype"
        pheno1$subtype <- gsub("pam50.+:", "", pheno1$subtype)
        pheno1 <- cbind(rownames(pheno[[i]]), pheno1)
        colnames(pheno1)[1] <- "Sample"
        pheno2[[names(pheno)[i]]] <- pheno1
      }
    }
    pheno3 <- do.call(rbind, pheno2)
    rownames(pheno3) <- NULL
    
  } else if(compare == "grade") {
    pheno2 <- list()
    for (i in seq_along(pheno)) {
      gradecoln <- grep("grade:", pheno[[i]])
      if(length(gradecoln) > 0) {
        pheno1 <- data.frame(pheno[[i]][ ,gradecoln])
        colnames(pheno1) <- "grade"
        pheno1$grade <- gsub("grade:|grade: |B-R grade: ", "", pheno1$grade)
        pheno1$grade <- gsub("=.+", "", pheno1$grade)
        greek <- grep("III", pheno1$grade)
        if(length(greek) > 0){
          one <- which(factor(pheno1$grade) == "I")
          two <- which(factor(pheno1$grade) == "II")
          three <- which(factor(pheno1$grade) == "III")
          pheno1[one, ] <- "1"
          pheno1[two, ] <- "2"
          pheno1[three, ] <- "3"
        }
        pheno1 <- cbind(rownames(pheno[[i]]), pheno1)
        colnames(pheno1)[1] <- "Sample"
        pheno2[[names(pheno)[i]]] <- pheno1
      }
    }
    pheno3 <- do.call(rbind, pheno2)
    rownames(pheno3) <- NULL
  }
  # Writing phenotype file
  write.csv(pheno3, paste0("Phenotype", "/", "phenotype_",compare, ".csv"), row.names = F, quote = F)
  message("Phenotype file is created into Phenotype folder")
}

MakeBoxPlot <- function(GEOmatrix,
                        projname) {
  # Make a long format data frame
  melted <- melt(GEOmatrix, id.vars= "ID")
  my_pal <- c("#1B9E77")
  # Plotting 
  ggplot(data = melted, aes(x = variable, y = value)) +
    geom_boxplot(aes(color = "#45B39D", fill= "#45B39D"), outlier.alpha = 0.1)+
    labs(x= 'SampleID', y= 'Values') +
    scale_y_continuous(labels = scales::comma) +
    theme_classic() +
    scale_color_manual(values=c(my_pal)) +
    scale_fill_manual(values=c(paste(my_pal, "66", sep = ""))) +
    theme(axis.text = element_text(family = "Arial",size = 24 , colour = "black", angle = 90),
          axis.text.x = element_text(family = "Arial",colour = "black", size = 6),
          axis.text.y = element_text(family = "Arial",colour = "black", size = 12),
          plot.subtitle = element_text(family = "Arial",size = 24, colour = "black", hjust = 0.5),
          axis.title.y = element_text(family = "Arial", size = 24, angle = 90),
          axis.title.x = element_text(family = "Arial", size = 24, angle = 00),
          legend.position="none") +
    labs(subtitle = paste0("Box plot - ", projname))
}

MakePCA <- function(GEOmatrix,
                    studies = NULL,
                    projname,
                    compare = "grade") {
  dir.create("Plots", showWarnings = F)
  # Reading matrix file
  set.seed(123)
  if(colnames(GEOmatrix)[1] == "ID"){
    rownames(GEOmatrix) <- GEOmatrix[,1]
    GEOmatrix <- GEOmatrix[,-1]
  }
  # Reading phenotype file
  pheno <- read_csv(paste0("Phenotype/phenotype_", compare, ".csv"))
  pheno <- data.frame(pheno)
  paired_pheno <- which(pheno$Sample %in% colnames(GEOmatrix))
  pheno <- pheno[paired_pheno, ]
  # PCA analysis
  GEOmatrix <- data.frame(t(GEOmatrix))
  pca_df <- scale(GEOmatrix)
  pca <- preProcess(x = pca_df, method = 'pca', pcaComp = 3)
  pca_df <- data.frame(predict(pca, pca_df))
  pca_df <- pca_df[order(rownames(pca_df)), ]
  pheno <- pheno[order(pheno$Sample), ]
  na_row <- which(is.na(pheno$grade))
  if(length(na_row) > 0){
    na_samp <- pheno[na_row,1]
    na_colm <- which(rownames(pca_df) %in% na_samp)
    pheno <- pheno[-na_row, ]
    pca_df <- pca_df[-na_colm, ]
  }
  pca_df$Class <- factor(pheno$grade)
  my_pal <- c("#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666", "#9A7D0A")
  # 2D plot for multi-studies
  if(length(projname) > 1) {
    pca_rownames <- rownames(pca_df)
    study_list <- studies
    batch <- list()
    for(i in seq_along(study_list)) {
      l <- length(which(colnames(study_list[[i]]) %in% pca_rownames))
      batch[[i]] <- rep(projname[i], l)
    }
    batch <- unlist(batch)
    pca_df$Studies <- factor(batch)
    ggplot(data = pca_df, aes(x = PC1, y = PC2, color = Class, fill = Class)) +
      geom_point(size = 3, aes( shape= Studies)) +
      scale_color_manual(values=c(my_pal)) +
      scale_fill_manual(values=c(paste(my_pal, "66", sep = ""))) +
      theme_classic() +
      theme(axis.text = element_text(family = "Arial",size = 24 , colour = "black"),
            axis.text.x = element_text(family = "Arial",colour = "black", size = 24),
            axis.text.y = element_text(family = "Arial",colour = "black", size = 24),
            plot.subtitle = element_text(family = "Arial",size = 24, colour = "black", hjust = 0.5),
            axis.title.y = element_text(family = "Arial", size = 24, angle = 90),
            axis.title.x = element_text(family = "Arial", size = 24, angle = 00),
            legend.text = element_text(size = 10, family = "Arial"), 
            legend.title = element_text(size = 20, family = "Arial")) +
      labs(subtitle = "PCA plot- Merged studies")
    
  } else {
    
    # Plotting
    plot3d( 
      x=pca_df$PC1, y=pca_df$PC2, z=pca_df$PC3, 
      col = my_pal[pca_df$Class],
      type = 's', 
      radius = 4,
      size = 3,
      xlab="PC1", ylab="PC2", zlab="PC3")
    # Legend
    legend3d("topright", 
             legend = levels(factor(pca_df$Class)), 
             title = compare,
             pch = 16,
             col = my_pal, 
             cex=1.2, 
             inset=c(0.02))
    
    # Saving the plot into Plots folder
    projname <- paste0(projname, collapse = "-") 
    htmlwidgets::saveWidget(rglwidget(width = 800, height = 800), 
                            file = paste0("Plots/PCA_", projname, ".html"),
                            libdir = "libs", title = paste0("PCA - ", projname),
                            selfcontained = FALSE)
  }
}

VSNQuantilNorm <- function(GEOmatrix) {
  set.seed(1234)
  # Reading matrix
  rownames(GEOmatrix) <- GEOmatrix[,1]
  GEOmatrix <- GEOmatrix[,-1]
  # VSN normalization
  vsnnorm <- normalizeVSN(GEOmatrix)
  # Quantile normalization
  df_rank <- apply(vsnnorm,2,rank,ties.method="min")
  df_sorted <- data.frame(apply(vsnnorm, 2, sort))
  df_mean <- apply(df_sorted, 1, mean)
  index_to_mean <- function(my_index, my_mean){
    return(my_mean[my_index])
  }
  norm_final <- apply(df_rank, 2, index_to_mean, my_mean=df_mean)
  norm_final <- data.frame(norm_final)
  norm_finall <- data.frame(sapply(norm_final, function(x) as.numeric(as.character(x))),
                    check.names=F)
  norm_finall <- cbind(rownames(GEOmatrix), norm_finall)
  colnames(norm_finall)[1] <- "ID"
  return(norm_finall)
}

MergeStudies <- function(studies) {
  # Merging two or more matrix
  study_list <- Reduce(function(x, y) merge(x, y, all=TRUE), studies)
  return(study_list)
}

StudyBatchEffect <- function(studies) {
  # Calculating the number of samples for each matrix
  study_list <- studies
  batch <- list()
  for(i in seq_along(study_list)) {
    batch[[i]] <- ncol(study_list[[i]]) - 1
  }
  batch <- unlist(batch)
  batch <- rep(seq_along(study_list), batch)
  # Merging matrices
  study_list <- Reduce(function(x, y) merge(x, y, all=TRUE), study_list)
  rownames(study_list) <- study_list[,1]
  study_list <- study_list[,-1]
  # Batch correction
  corrected_batch <- ComBat(dat=study_list,
                            batch=batch,
                            mod=NULL,
                            par.prior=TRUE, 
                            prior.plots=FALSE)
  corrected_batch <- data.frame(corrected_batch)
  corrected_batch <- data.frame(sapply(corrected_batch, function(x) as.numeric(as.character(x))),
                            check.names=F, row.names = rownames(corrected_batch))
  corrected_batch <- cbind(rownames(corrected_batch), corrected_batch)
  colnames(corrected_batch)[1] <- "ID"
  return(corrected_batch)
}

MakeDensityPlot <- function(matrix, studies) {
  set.seed(1234)
  # Make a long format data frame
  melted <- melt(matrix, id.vars = "ID")
  # Calculating the number of samples for each study 
  st <- list()
  for(i in seq_along(studies)){
    row_n <- nrow(studies[[i]])
    col_n <- ncol(studies[[i]]) -1
    st[[i]] <- rep(names(studies)[i], row_n*col_n)
  }
  st <- unlist(st)
  melted$Studies <- factor(st)
  # Plotting
  my_pal <- c("#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666", "#9A7D0A")
  ggplot(data = melted, aes(x = value, color = Studies)) +
    geom_density(size = 1.5) +
    labs(y= 'Density', x= 'Value') +
    theme_classic() +
    scale_color_manual(values=c(my_pal)) +
    scale_fill_manual(values=c(paste(my_pal, "66", sep = ""))) +
    theme(axis.text = element_text(family = "Arial",size = 24 , colour = "black", angle = 90),
          axis.text.x = element_text(family = "Arial",colour = "black", size = 12),
          axis.text.y = element_text(family = "Arial",colour = "black", size = 24),
          plot.subtitle = element_text(family = "Arial",size = 24, colour = "black", hjust = 0.5),
          axis.title.y = element_text(family = "Arial", size = 24, angle = 90),
          axis.title.x = element_text(family = "Arial", size = 24, angle = 00)) +
    labs(subtitle = "Density plot")
} 

MakeMDSPlot <- function(matrix,
                        studies,
                        projname,
                        compare, 
                        nstudies) {
  set.seed(1234)
  if(colnames(matrix)[1] == "ID"){
    rownames(matrix) <- matrix[,1]
    matrix <- matrix[,-1]
  }
  matrix <- data.frame(t(matrix))
  # Cmpute MDS
  mds <- matrix %>%
    dist() %>%          
    cmdscale() %>%
    data.frame()
  colnames(mds) <- c("Dim1", "Dim2")
  # Clustering
  clust <- kmeans(mds, nstudies)$cluster %>%
    as.factor()
  mds <- mds %>%
    mutate(Clusters = clust)
  # Finding studies names
  mds_rownames <- rownames(mds)
  study_list <- studies
  batch <- list()
  for(i in seq_along(study_list)) {
    l <- length(which(colnames(study_list[[i]]) %in% mds_rownames))
    batch[[i]] <- rep(projname[i], l)
  }
  batch <- unlist(batch)
  mds$Studies <- factor(batch) 
  
  # Plot and color by groups
  my_pal <- c("#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666", "#9A7D0A")
  g <- ggscatter(mds, x = "Dim1", y = "Dim2", 
                 label = rownames(mds),shape = "Studies", 
                 ggtheme = theme_classic(),
                 color = "Clusters",
                 palette = my_pal,
                 size = 1.5, 
                 ellipse = TRUE,
                 ellipse.type = "convex",
                 repel = TRUE)
  g + theme(axis.text = element_text(family = "Arial",size = 24 , colour = "black"),
            axis.text.x = element_text(family = "Arial",colour = "black", size = 24),
            axis.text.y = element_text(family = "Arial",colour = "black", size = 24),
            plot.subtitle = element_text(family = "Arial",size = 24, colour = "black", hjust = 0.5),
            axis.title.y = element_text(family = "Arial", size = 24, angle = 90),
            axis.title.x = element_text(family = "Arial", size = 24, angle = 00)) +
    labs(subtitle = "MDS plot")
}

CochranQTest <- function(studies, groups, compare) {
  set.seed(1234)
  # Reading matrix and phenotype
  d.adj.Split <- list()
  var.d.adj.Split <- list()
  for(i in seq_along(studies)) {
    matrix <- studies[[i]]
    if(colnames(matrix)[1] == "ID"){
      rownames(matrix) <- matrix[,1]
      matrix <- matrix[,-1]
    }
    pheno <- read_csv(paste0("Phenotype/phenotype_", compare, ".csv"))
    pheno <- data.frame(pheno)
    paired_pheno <- which(pheno$Sample %in% colnames(matrix))
    pheno <- pheno[paired_pheno, ]
    na_row <- which(is.na(pheno$grade))
    # Matching phenotype with samples in matrix 
    if(length(na_row) > 0){
      na_samp <- pheno[na_row,1]
      na_colm <- which(colnames(matrix) %in% na_samp)
      pheno <- pheno[-na_row, ]
      matrix <- matrix[,  -na_colm]
    }
    # Calculating the number of each comparison mode (grade1 vs grade3)
    g_list <- list()
    sampleid <- list()
    for(j in seq_along(groups)){
      g_row <- which(pheno$grade %in% groups[j])
      s_id <- pheno[g_row,1]
      sampleid[[j]] <- s_id
      g_list[[j]] <- factor(rep(j - 1, length(g_row)))
    }
    # Applying those modes and calculating the mean and variance for Cochran' Q Test
    spl <- unlist(g_list)
    spsam <- unlist(sampleid)
    matrix <- matrix[,spsam]
    matrix <- as.matrix(matrix)
    d.Split <- getdF(matrix, spl)
    mean_d <- dstar(d.Split, length(spl))
    d.adj.Split[[i]] <- mean_d
    var_d <- sigmad(mean_d, sum(spl==0), sum(spl==1))
    var.d.adj.Split[[i]] <- var_d
  }
  # Output means and variances as a list
  output <- list(d.adj.Split, var.d.adj.Split)
  return(output)
  message("Analysis has completed.")
}

MakeQQPlot <- function(cohranq, nstudies) {
  # Unpack the previous list into data frames
  output1 <- cohranq[[1]] 
  output2 <- cohranq[[2]]
  mymns <- data.frame(do.call(cbind, output1))
  myvars <- data.frame(do.call(cbind, output2))
  # Calculating Cochran' Q Test
  my.Q <- f.Q(mymns, myvars)
  nstudies <- nstudies
  #quantiles of the chisq distribution
  chisqq <- qchisq(seq(0, .9999, .001), df = nstudies-1)
  tmp <- quantile(my.Q, seq(0, .9999, .001))
  qq <- data.frame(chisqq = chisqq, tmp = tmp)
  # Plotting
  ggplot(data = qq, aes(x = chisqq, y = tmp, color = "#1B9E77")) +
    geom_point() +
    geom_abline() +
    theme_classic() +
    labs(x= 'Quantiles of Chi square', y= 'Quantiles of Sample') +
    theme(axis.text = element_text(family = "Arial",size = 24 , colour = "black"),
          axis.text.x = element_text(family = "Arial",colour = "black", size = 24),
          axis.text.y = element_text(family = "Arial",colour = "black", size = 24),
          plot.subtitle = element_text(family = "Arial",size = 24, colour = "black", hjust = 0.5),
          axis.title.y = element_text(family = "Arial", size = 24, angle = 90),
          axis.title.x = element_text(family = "Arial", size = 24, angle = 00),
          legend.position="none") +
    labs(subtitle = "QQ Plot")
} 

FEMREMAnalysis <- function(studies,
                           projname,
                           compare,
                           groups,
                           model,
                           FDR,
                           nperm) {
  set.seed(1234)
  # Creating folders
  dir.create("MetaAnalysis", showWarnings = F)
  dir.create("MetaAnalysis/filtered", showWarnings = F)
  dir.create("MetaAnalysis/volcano", showWarnings = F)
  # Reading phenotype file
  phenotype <- read_csv(paste0("Phenotype/phenotype_", compare, ".csv"))
  phenotype <- data.frame(phenotype)
  # Reading annotation file
  annotations <- list()
  for(i in seq_along(projname)){
    annot <- read_tsv(paste0(projname[i], "/", "annot.tsv"))
    annot <- data.frame(annot)
    rownames(annot) <- annot[,1]
    annot <- annot[,-1]
    annot <- annot[ , c("Gene.symbol", "Chromosome.location", "GO.Function")]
    annot <- cbind(rownames(annot), annot)
    colnames(annot)[1] <- "ID" 
    annot <- annot[order(annot$ID), ]
    annotations[[projname[i]]] <- annot
  }
  an <- Reduce(intersect, annotations)
  annotations <- data.frame(do.call(cbind, an))
  matrices_list <- list()
  class <- list()
  for(i in seq_along(studies)) {
    matrix <- studies[[i]]
    if(colnames(matrix)[1] == "ID"){
      rownames(matrix) <- matrix[,1]
      matrix <- matrix[,-1]
    }
    paired_pheno <- which(phenotype$Sample %in% colnames(matrix))
    pheno <- phenotype[paired_pheno, ]
    na_row <- which(is.na(pheno$grade))
    # Matching phenotype with samples in matrix 
    if(length(na_row) > 0){
      na_samp <- pheno[na_row,1]
      na_colm <- which(colnames(matrix) %in% na_samp)
      pheno <- pheno[-na_row, ]
      matrix <- matrix[,  -na_colm]
    }
    
    # Calculating the number of each comparison mode (grade1 vs grade3)
    g_list <- list()
    sampleid <- list()
    for(j in seq_along(groups)){
      g_row <- which(pheno$grade %in% groups[j])
      s_id <- pheno[g_row,1]
      sampleid[[j]] <- s_id
      g_list[[j]] <- factor(rep(j - 1, length(g_row)))
    }
    
    spl <- unlist(g_list)
    spl <- as.numeric(as.character(spl))
    class[[i]] <- spl
    spsam <- unlist(sampleid)
    matrix <- matrix[,spsam]
    matrix <- as.matrix(matrix)
    matrix <- ExpressionSet(assayData=matrix)
    matrices_list[[i]] <- matrix
  }
  if(model == 'FEM') {
    useREM <- FALSE
  } 
  if(model == 'REM') {
    useREM <- TRUE
  }
  ScoresFDR <- zScoreFDR(matrices_list, class, useREM = useREM, nperm = nperm)
  twosided <- data.frame(ScoresFDR[["two.sided"]])
  twosided <- twosided[order(rownames(twosided)),]
  # Adding annotation
  anno_row <- which(annotations$ID %in% rownames(twosided))
  twosided <- cbind(twosided,  annotations[anno_row, c(2, 3, 4)])
  # Removing missing gene symbols
  genemissing <- which(is.na(twosided$Gene.symbol) == TRUE)
  twosided <- twosided[-genemissing, ]
  # All studies
  combination <- twosided[ ,c("zSco", "FDR", "Gene.symbol", "Chromosome.location", "GO.Function")]
  dupgene_freq <- data.frame(table(combination$Gene.symbol))
  only_dupgene <- dupgene_freq[which(dupgene_freq$Freq > 1), 1]
  only_dupgene_row <- which(combination$Gene.symbol %in% only_dupgene)
  duplicat_deg <- combination[only_dupgene_row,]
  
  averaged_genes <- list()
  for(b in 1:length(only_dupgene)){
    d_row <- which(duplicat_deg$Gene.symbol %in% only_dupgene[b])
    col_mean <- rbind(colMeans(duplicat_deg[d_row, 1:2]))
    col_all <- cbind(col_mean, duplicat_deg[d_row[1],3:5])
    averaged_genes[[b]] <- col_all
  }
  averaged_genes <- do.call(rbind, averaged_genes)
  unique_deg <- combination[-only_dupgene_row, ]
  all_unique_genes_combi <- rbind(unique_deg, averaged_genes)
  rownames(all_unique_genes_combi) <- NULL
  
  all_unique_genes_combi <- all_unique_genes_combi[order(all_unique_genes_combi[,1], decreasing = T),]
  write_tsv(all_unique_genes_combi, "MetaAnalysis/volcano/combination.tsv")
  # All studies with FDR filtering
  all_unique_genes_combi <- all_unique_genes_combi[which(all_unique_genes_combi[, "FDR"] < FDR),]
  write_tsv(all_unique_genes_combi, "MetaAnalysis/filtered/combination.tsv")
  
  # Seperating each study, averaging duplicated genes
  sfdr <- grep("FDR_Ex_{0-9}", colnames(twosided))
  for(i in seq_along(sfdr)){
    gs_col <- grep("Gene.symbol|Chromosome.location|GO.Function", colnames(twosided))
    common <- twosided[,c(sfdr[i]-1, sfdr[i], gs_col)]
    colnames(common)[1:2] <- gsub("Ex_.", projname[i],colnames(common)[1:2])
    if(nrow(common) > 1){
      dupgene_freq <- data.frame(table(common$Gene.symbol))
      only_dupgene <- dupgene_freq[which(dupgene_freq$Freq > 1), 1]
      only_dupgene_row <- which(common$Gene.symbol %in% only_dupgene)
      duplicat_deg <- common[only_dupgene_row,]
      
      averaged_genes <- list()
      for(b in 1:length(only_dupgene)){
        d_row <- which(duplicat_deg$Gene.symbol %in% only_dupgene[b])
        col_mean <- rbind(colMeans(duplicat_deg[d_row, 1:2]))
        col_all <- cbind(col_mean, duplicat_deg[d_row[1],3:5])
        averaged_genes[[b]] <- col_all
      }
      averaged_genes <- do.call(rbind, averaged_genes)
      unique_deg <- common[-only_dupgene_row, ]
      all_unique_genes <- rbind(unique_deg, averaged_genes)
      rownames(all_unique_genes) <- NULL
      all_unique_genes <- all_unique_genes[order(all_unique_genes[,1], decreasing = T),]
      write_tsv(all_unique_genes, paste0("MetaAnalysis/volcano/", projname[i], ".tsv"))
      all_unique_genes <- all_unique_genes[which(all_unique_genes[,2] < FDR),]
      write_tsv(all_unique_genes, paste0("MetaAnalysis/filtered/", projname[i], ".tsv"))
    }
    
    eslash_genes <- length(grep("///", all_unique_genes$Gene.symbol))
    message("###################### Summary for: ", projname[i], " ############################")
    message(cat("Number of missing gene symbols:", length(genemissing),
                "\nNumber of duplicated genes:", length(only_dupgene),
                "\nTotal number of genes after averaging duplicated genes and FDR filter:", NROW(all_unique_genes),
                "\nNumber of genes having ///:", eslash_genes))
    message("##########################################################################")
  }
  
  message("+++++++++++++++++++++++ Analysis has completed. +++++++++++++++++++++++")
}

Makevolcano <- function(projname = "GSE11121",
                        padjlevel = 0.05,
                        pSE_thresh = 1,
                        nSE_thresh = -1,
                        ntop = 10,
                        voltype = "ggplot") {
  dir.create("MetaAnalysis/DEG", showWarnings = F)
  # Reading the DEGs table
  volcano <- read_tsv(paste0("MetaAnalysis/volcano/", projname, ".tsv"))
  volcano <- data.frame(volcano)
  colnames(volcano)[1:2] <- gsub(paste0("_", projname), "", colnames(volcano)[1:2])
  #volcano <- volcano[which(volcano$FDR != 0), ]
  volcano <- volcano %>%
    mutate(AdjustedPvalue = -log10(FDR)) %>%
    mutate(DEG = "NotSignificant") %>%
    mutate(DEG = ifelse(AdjustedPvalue > -log10(padjlevel) & zSco > pSE_thresh, "Upregulated", DEG)) %>%
    mutate(DEG = ifelse(AdjustedPvalue > -log10(padjlevel) & zSco < nSE_thresh, "Downregulated", DEG))
  
  
  zero_fdr <- which(volcano$FDR == 0)
  m <- -log10(min(volcano[-zero_fdr, "FDR"])) + 0.5
  volcano[zero_fdr, "AdjustedPvalue"] <- m
  # Colors
  my_pal <- c("#1B9E77","#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666", "#9A7D0A")
  # Calculating the number of each Upregulated, Downregulated, and NotSignificant probes
  volcano_up <- volcano[which(volcano$DEG == "Upregulated"),]
  volcano_down <- volcano[which(volcano$DEG == "Downregulated"),]
  volcano_down <- volcano_down[order(volcano_down$zSco, decreasing = F), ]
  volcano_NA <- volcano[which(volcano$DEG == "NotSignificant"),]
  # Combining all with together 
  volcano_all <- rbind(volcano_up, volcano_down, volcano_NA)
  # Replacing the top probes with word Top
  ntop_rep <- rep("Top", ntop)
  volcano_all$DEG <- c(ntop_rep, volcano_up$DEG[-c(1:ntop)], ntop_rep, volcano_down$DEG[-c(1:ntop)], volcano_NA$DEG)
  # Label only top genes
  volcano_all$Top <- ifelse(volcano_all$DEG == "Top", volcano_all$Gene.symbol, "")
  # Plotting either with plotly or ggplot
  if(voltype == "ggplot"){
    p <- ggplot(data = volcano_all, aes(x = zSco, y= AdjustedPvalue, color= DEG, fill = DEG, label= Top)) + 
      labs(x= 'Effect size', y= "-log10(FDR)") +
      geom_point(size = 1, shape = 21) +
      geom_text(check_overlap = T,vjust = 0.1, nudge_y = 0.1) +
      scale_color_manual(values=c(my_pal)) +
      scale_fill_manual(values=c(paste(my_pal, "66", sep = ""))) +
      theme_classic() +
      theme(axis.text = element_text(family = "Arial",size = 24 , colour = "black"),
            axis.text.x = element_text(family = "Arial",colour = "black", size = 24),
            axis.text.y = element_text(family = "Arial",colour = "black", size = 24),
            plot.subtitle = element_text(family = "Arial",size = 24, colour = "black", hjust = 0.5),
            axis.title.y = element_text(family = "Arial", size = 24, angle = 90),
            axis.title.x = element_text(family = "Arial", size = 24, angle = 00),
            legend.text = element_text(size = 10, family = "Arial"), 
            legend.title = element_text(size = 20, family = "Arial")) +
      labs(subtitle = paste0("Volcano plot-", projname))
    p
  } else {
    # Creating ggplot object, adding layers and annotation to the plot
    p <- ggplot(data = volcano_all, aes(x = zSco, y= AdjustedPvalue, color= DEG, fill = DEG, text = paste(
      "<br>Gene: ", Gene.symbol,
      "<br>Chromosome: ", Chromosome.location,
      "<br>GO function: ", GO.Function))) +
      labs(x= 'Effect size', y= "-log10(FDR)", title = paste0("Volcano plot-", projname)) +
      geom_point(size = 1, shape = 21) +
      scale_color_manual(values=c(my_pal)) +
      scale_fill_manual(values=c(paste(my_pal, "66", sep = ""))) +
      theme_classic() +
      theme(axis.text = element_text(family = "Arial",size = 24 , colour = "black"),
            axis.text.x = element_text(family = "Arial",colour = "black", size = 24),
            axis.text.y = element_text(family = "Arial",colour = "black", size = 24),
            plot.subtitle = element_text(family = "Arial",size = 24, colour = "black", hjust = 0.5),
            axis.title.y = element_text(family = "Arial", size = 24, angle = 90),
            axis.title.x = element_text(family = "Arial", size = 24, angle = 00))
    p <- ggplotly(p, tooltip = "text") %>%
      layout(title = paste0("Volcano plot-", projname),
             font = list(family = "Arial", color = "black", size = 24),
             legend = list(family = "Arial", color = "black", size = 20, itemclick = "toggle"))
  }
  # Calculation the up and down regulated genes number
  write_tsv(rbind(volcano_up, volcano_down), paste0("MetaAnalysis/DEG/", projname, "_up_down.tsv"))
  # Creating the top table (up and down) based on the number specified (ntop)
  top <- rbind(volcano_up[1:ntop, ], volcano_down[1:ntop, ])
  top <- top[,-6]
  # Save top table into project folder
  write_tsv(top, paste0("MetaAnalysis/DEG/", projname, "_top.tsv"))
  
  message("################# Significance #################")
  message(cat("Up-regulated genes:", nrow(volcano_up),
              "\nDown-regulated geges:", nrow(volcano_down)))
  message("################################################")
  return(p)
}

MakeVenna <- function(common,
                      ntop = 10) {
  
  dir.create("MetaAnalysis/common", showWarnings = F)
  # Reading all all_top_down files
  com_table <- list()
  for(i in seq_along(common)){
    DEG_table <- data.frame(read_tsv(paste0("MetaAnalysis/DEG/", common[i], "_up_down.tsv")))
    com_table[[common[i]]] <- DEG_table[,-6]
  }
  # Calculating up and down regulated gens
  DEGslist <- list()
  for(i in seq_along(com_table)){
    DEGslist[[common[i]]] <- com_table[[i]][[3]]
  }
  # Common genes
  com_prob <- Reduce(intersect, DEGslist)
  # Writing all common genes into separated files as well as the top files
  all_com <- list()
  for(i in seq_along(com_table)){
    comn <- which(com_table[[names(com_table)[i]]][["Gene.symbol"]] %in% com_prob)
    com_final_DEG  <- com_table[[names(com_table)[i]]][comn, ]
    write_tsv(com_final_DEG, paste0("MetaAnalysis/common/",names(com_table)[i],"_common_DEGs.tsv"))
    sorted_com_final_DEG <- com_final_DEG[order(com_final_DEG$Gene.symbol),]
    all_com[[names(com_table)[i]]] <- sorted_com_final_DEG
    com_final_up <- com_final_DEG[which(com_final_DEG$DEG == "Upregulated"), ]
    com_final_up <- com_final_up[1:ntop, ]
    com_final_down <- com_final_DEG[which(com_final_DEG$DEG == "Downregulated"), ]
    com_final_down <- com_final_down[1:ntop, ]
    write_tsv(rbind(com_final_up, com_final_down), paste0("MetaAnalysis/common/", names(com_table)[i],"_top_common_DEGs.tsv"))
  }
  
  firstsecond_col <- list()
  remaining <- list()
  for(i in seq_along(all_com)){
    firstsecond_col[[i]] <- data.frame(all_com[[i]][,1:2])
    remaining[[i]] <- data.frame(all_com[[i]][,3:6])
  }
  
  firstsecond_col_df <- do.call(cbind, firstsecond_col)
  sz <- grep("zSco", colnames(firstsecond_col_df))
  fdr <- grep("FDR", colnames(firstsecond_col_df))
  sz_mean <- rowMeans(firstsecond_col_df[,sz])
  fdr_mean <- rowMeans(firstsecond_col_df[,fdr])
  sz_fdr_df <- data.frame(zSco = sz_mean, FDR= fdr_mean)
  sz_fdr_df <- cbind(sz_fdr_df, remaining[[1]])
  write_tsv(sz_fdr_df, paste0("MetaAnalysis/common/all_mean_common_DEGs.tsv"))
  
  
  message("+++++ Common genes between all datasets have saved into common folder. +++++")
  # Creating venn diagram
  DEGslist <- list()
  for(i in seq_along(com_table)){
    DEGslist[[common[i]]] <- com_table[[i]][3]
  }
  venlist <- list()
  for(i in seq_along(DEGslist)){
    venlist[[common[i]]] <- DEGslist[[i]][[1]]
  }
  set.seed(1234)
  my_pal <- c("#1B9E77","#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666", "#9A7D0A")
  venaa <- ggvenn(venlist, 
                  fill_color = my_pal,
                  stroke_size = 0.5,
                  set_name_size = 4)
  return(venaa)
}

Makenetworkanalyst <- function(matrix,
                               projname,
                               compare = "grade",
                               groups) {
  # Reading files
  dir.create("MetaAnalysis/networkanalyst", showWarnings = F)
  if(colnames(matrix)[1] == "ID"){
    rownames(matrix) <- matrix[,1]
    matrix <- matrix[,-1]
  }
  
  pheno <- read_csv(paste0("Phenotype/phenotype_", compare, ".csv"))
  pheno <- data.frame(pheno)
  paired_pheno <- which(pheno$Sample %in% colnames(matrix))
  pheno <- pheno[paired_pheno, ]
  
  annot <- read_tsv(paste0(projname, "/", "annot.tsv"))
  annot <- data.frame(annot)
  rownames(annot) <- annot[,1]
  annot <- annot[,-1]
  # Finding matching grades or subtypes
  sampleid <- list()
  for(i in seq_along(groups)){
    g_row <- which(pheno$grade %in% groups[[i]])
    sampleid[[i]] <- pheno[g_row, ]
  }
  sampleid <- do.call(rbind, sampleid)
  sampleid <- sampleid[order(sampleid$Sample),]
  matrix <- matrix[, sampleid$Sample]
  matrix <- round(matrix, 2)
  identical(rownames(matrix), rownames(annot))
  matrix <- cbind(annot$Gene.symbol, matrix)
  colnames(matrix)[1] <- "Gene.symbol"
  genemissing <- which(is.na(matrix$Gene.symbol) == TRUE)
  matrix <- matrix[-genemissing, ]

  grouplis <- list()
  for(i in seq_along(groups)){
    name <- paste0(groups[[i]], collapse = "|")
    rownum <- grep(name, pheno$grade)
    grouplis[[names(groups)[i]]] <- pheno$Sample[rownum]
  }
  # Renaming the matrix file according to the groups name specified by user 
  updown_matrix <- rbind(colnames(matrix), matrix)
  for(i in seq_along(grouplis)){
    matname <- paste0(grouplis[[i]], collapse = "|")
    matcoln <- grep(matname, colnames(updown_matrix))
    updown_matrix[1,matcoln] <- names(grouplis)[i]
  }
  # Adding col names and second row according to the file for networkanalyst
  changedcol <- grep(paste0(names(grouplis), collapse = "|"), updown_matrix[1,])
  updown_matrix <- updown_matrix[, c(1, changedcol)]
  updown_matrix[1,1] <- "#CLASS"
  colnames(updown_matrix)[1] <- "#NAME"
  write.table(updown_matrix, paste0("MetaAnalysis/networkanalyst/", projname,"_network_full.txt"), quote = F, row.names = F, sep = "\t")
  message("+++++ Your file has saved into networkanalyst folder. +++++")
}

MakeHeatmap <- function(matrix,
                        projname,
                        compare,
                        groups,
                        ntop, 
                        sorted){
  set.seed(1234)
  if(colnames(matrix)[1] == "ID"){
    rownames(matrix) <- matrix[,1]
    matrix <- matrix[,-1]
    matrix <- matrix[order(rownames(matrix)),]
  }
  # Reading phenotype
  pheno <- read_csv(paste0("Phenotype/phenotype_", compare, ".csv"))
  pheno <- data.frame(pheno)
  # Reading annotation  
  if(projname == "combination"){
    annot <- data.frame(read_tsv(paste0("GSE25055", "/", "annot.tsv")))
  } else{
    annot <- data.frame(read_tsv(paste0(projname, "/", "annot.tsv")))
  }
  annot <- annot[ , c("ID","Gene.symbol")]
  annot <- annot[order(annot$ID), ]
  if(identical(rownames(matrix), annot$ID)){
    matrix <- cbind(annot$Gene.symbol, matrix)
    colnames(matrix)[1] <- "Gene.symbol"
  }
  # Averaging duplicated genes
  dupgene_freq <- data.frame(table(matrix$Gene.symbol))
  only_dupgene <- dupgene_freq[which(dupgene_freq$Freq > 1), 1]
  only_dupgene_row <- which(matrix$Gene.symbol %in% only_dupgene)
  duplicat_deg <- matrix[only_dupgene_row,]
  
  averaged_genes <- list()
  for(i in 1:length(only_dupgene)){
    d_row <- which(duplicat_deg$Gene.symbol %in% only_dupgene[i])
    col_mean <- rbind(colMeans(duplicat_deg[d_row, -1]))
    col_all <- cbind(duplicat_deg[d_row[1],1], col_mean)
    averaged_genes[[i]] <- col_all
  }
  averaged_genes <- data.frame(do.call(rbind, averaged_genes))
  colnames(averaged_genes)[1] <- "Gene.symbol"
  unique_deg <- matrix[-only_dupgene_row, ]
  all_unique_genes <- rbind(unique_deg, averaged_genes)
  rownames(all_unique_genes) <- NULL
  # Reading DEG file
  DEG_table <- data.frame(read_tsv(paste0("MetaAnalysis/DEG/", projname, "_up_down.tsv")))
  # Finding up and down regulated gene and make original matrix of them
  up <- DEG_table[which(DEG_table$DEG == "Upregulated"),]
  up <- up[1:ntop,2:3]
  down <- DEG_table[which(DEG_table$DEG == "Downregulated"),]
  down <- down[1:ntop, 2:3]
  genelist <- rbind(up, down)[,2]
  num <- which(all_unique_genes$Gene.symbol %in% genelist)
  network_df <- data.frame(all_unique_genes[num,])
  Gene.symbol <- network_df$Gene.symbol
  network_df <- network_df[,-1]
  network_df <- as.matrix(sapply(network_df, as.numeric))
  rownames(network_df) <- Gene.symbol
  
  # Finding grades and matching with colnames
  sampleid <- list()
  for(i in seq_along(groups)){
    g_row <- which(pheno$grade %in% groups[[i]])
    sampleid[[i]] <- pheno[g_row, ]
  }
  sampleid <- do.call(rbind, sampleid)
  sampleid_n <- which(sampleid$Sample %in% colnames(network_df))
  sampleid <- sampleid[sampleid_n,]
  sampleid <- sampleid[order(sampleid$grade),]
  sampleid$grade <- paste0("Grade_", sampleid$grade) 
  network_df <- network_df[, sampleid$Sample]
  colnames(network_df) <- sampleid$grade 
  # Grade info
  type <- colnames(network_df)
  ha = HeatmapAnnotation(
    df = data.frame(Grade = type),
    annotation_height = unit(4, "mm")
  )
  # Heatmap plot
  if(sorted == TRUE){
  Heatmap(network_df,
          row_names_gp = gpar(fontsize = 7),
          bottom_annotation= ha,
          column_order = colnames(network_df),
          border_gp = gpar(col = "black"),
          row_title = "DEGs",
          row_title_side = "left",
          show_column_names = FALSE,
          heatmap_legend_param = list(legend_direction = "vertical",
                                      legend_height = unit(50, "mm"),
                                      grid_width = unit(6, "mm"),
                                      grid_height = unit(50, "cm"),
                                      title = "Expression"))
  } else {
    Heatmap(network_df,
            row_names_gp = gpar(fontsize = 7),
            bottom_annotation= ha,
            border_gp = gpar(col = "black"),
            row_title = "DEGs",
            row_title_side = "left",
            show_column_names = FALSE,
            heatmap_legend_param = list(legend_direction = "vertical",
                                        legend_height = unit(50, "mm"),
                                        grid_width = unit(6, "mm"),
                                        grid_height = unit(50, "cm"),
                                        title = "Expression"))
  }
}

GSEAAnalysis <- function(projname, FDR){
  # Reading file 
  DEG_table <- data.frame(read_tsv(paste0("MetaAnalysis/DEG/", projname, "_up_down.tsv")))
  # Removing /// from some genes
  DEG_table$Gene.symbol <- gsub("///.*", "", DEG_table$Gene.symbol)
  # Extracting Halmark pathway with 50 gene sets 
  H <- msigdbr(species = "Homo sapiens", category = "H")
  H.symbol.ls <- H %>% 
    select(gs_name, gene_symbol) %>% 
    group_by(gs_name) %>% 
    summarise(all.genes = list(unique(gene_symbol))) %>% 
    deframe()
  # Just gene names and logFC
  FC <- DEG_table[,c(3,1)]
  
  ##format for gsea 
  FC.vec <- FC$zSco
  names(FC.vec) <- FC$Gene.symbol
  #Run GSEA
  gsea.H <- fgseaSimple(pathways = H.symbol.ls,
                        stats = FC.vec,
                        scoreType = "std",
                        nperm=1000)

  my_pal <- c("#1B9E77","#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666", "#9A7D0A")
  # Remove prefixes
  gsea.H$pathway <- gsub("HALLMARK_","", gsea.H$pathway)
  gsea.H$pathway <- gsub("_"," ", gsea.H$pathway)
  # Calculating the Significance based on FDR and NES
  gsea.H <- gsea.H %>%
    mutate(Significance = "NotSignificance") %>%
    mutate(Significance = ifelse(padj <= FDR & NES > 0, "Upregulated", Significance)) %>%
    mutate(Significance = ifelse(padj <= FDR & NES < 0, "Downregulated", Significance))
  gsea.H <- gsea.H[which(gsea.H$Significance != "NotSignificance"), ]
  # Plotting the result
  gsea.H %>% 
    ggplot(aes(x=reorder(pathway, NES),
               y=NES)) +
    geom_col(width = 0.5, aes(color= Significance, fill = Significance)) +
    labs(x= 'Gene set', y= "Normalized enrichment score (NES)") +
    theme_classic() +
    scale_color_manual(values=c("blue", "red")) +
    scale_fill_manual(values=c("blue", "red")) +
    coord_flip() +
    theme(axis.text = element_text(family = "Arial",size = 24 , colour = "black"),
          axis.text.x = element_text(family = "Arial",colour = "black", size = 24),
          axis.text.y = element_text(family = "Arial",colour = "black", size = 9),
          plot.subtitle = element_text(family = "Arial",size = 24, colour = "black", hjust = 0.5),
          axis.title.y = element_text(family = "Arial", size = 24, angle = 90),
          axis.title.x = element_text(family = "Arial", size = 24, angle = 00),
          legend.text = element_text(size = 10, family = "Arial"), 
          legend.title = element_text(size = 20, family = "Arial")) +
    labs(subtitle = paste0("GSEA - ", projname))
}

####################################### Running all functions ###############################################

# Downloading GEO 
DownloadGEO("GSE25065")
DownloadGEO("GSE11121")
DownloadGEO("GSE7390")
DownloadGEO("GSE25055")
# Reading GEO matrix into R environment
GSE11121 <- ReadGEO("GSE11121")
GSE25055 <- ReadGEO("GSE25055")
GSE25065 <- ReadGEO("GSE25065")
GSE7390 <- ReadGEO("GSE7390")
# Preparing phenotype for all 4 GEO 
MakePhenotype(projname = c("GSE11121", "GSE25055", "GSE25065", "GSE7390"),
              compare = "grade")

# Box plot for each matrix
MakeBoxPlot(GEOmatrix = GSE11121, projname = "GSE11121")
MakeBoxPlot(GEOmatrix = GSE25065, projname = "GSE25065")
MakeBoxPlot(GEOmatrix = GSE25055, projname = "GSE25055")
MakeBoxPlot(GEOmatrix = GSE7390, projname = "GSE7390")

# PCA plot for each matrix
MakePCA(GEOmatrix = GSE11121, projname = "GSE11121", compare = "grade")
MakePCA(GEOmatrix = GSE25065, projname = "GSE25065", compare = "grade")
MakePCA(GEOmatrix = GSE25055, projname = "GSE25055", compare = "grade")
MakePCA(GEOmatrix = GSE7390, projname = "GSE7390", compare = "grade")

# Normalization for each matrix
normalized_GSE11121 <- VSNQuantilNorm(GEOmatrix = GSE11121)
normalized_GSE25055 <- VSNQuantilNorm(GEOmatrix = GSE25055)
normalized_GSE25065 <- VSNQuantilNorm(GEOmatrix = GSE25065)
normalized_GSE7390 <- VSNQuantilNorm(GEOmatrix = GSE7390)

# Box and PCA after normalization for some matrix
MakeBoxPlot(GEOmatrix = normalized_GSE11121, projname = "GSE11121")
MakePCA(GEOmatrix = normalized_GSE11121, projname = "GSE11121", compare = "grade")

MakeBoxPlot(GEOmatrix = normalized_GSE25055, projname = "GSE25055")
MakePCA(GEOmatrix = normalized_GSE25055, projname = "GSE25055", compare = "grade")

MakeBoxPlot(GEOmatrix = normalized_GSE25065, projname = "GSE25065")
MakePCA(GEOmatrix = normalized_GSE25065, projname = "GSE25065", compare = "grade")

MakeBoxPlot(GEOmatrix = normalized_GSE7390, projname = "GSE7390")
MakePCA(GEOmatrix = normalized_GSE7390, projname = "GSE7390", compare = "grade")

# Merging studies without batch correction (just for comparison)
merge_studies <- MergeStudies(list(normalized_GSE25055, normalized_GSE11121, normalized_GSE25065, normalized_GSE7390))

# PCA before batch effect 
# Important note : studies should match projname 
MakePCA(GEOmatrix = merge_studies, 
        studies = list(normalized_GSE25055, normalized_GSE11121, normalized_GSE25065, normalized_GSE7390), 
        projname = c("GSE25055", "GSE11121", "GSE25065", "GSE7390"), 
        compare = "grade")

# Batch effect correction
corbatch <- StudyBatchEffect(studies = list(normalized_GSE25055, normalized_GSE11121, normalized_GSE25065, normalized_GSE7390))

# PCA after batch effect 
# Important note : studies should match projname 
MakePCA(GEOmatrix = corbatch, 
        studies = list(normalized_GSE25055, normalized_GSE11121, normalized_GSE25065, normalized_GSE7390), 
        projname = c("GSE25055", "GSE11121", "GSE25065", "GSE7390"), compare = "grade")




# Density plot before batch effect correction
MakeDensityPlot(matrix = merge_studies, 
                studies = list(GSE25055 = normalized_GSE25055, 
                               GSE11121 = normalized_GSE11121, 
                               GSE25065 = normalized_GSE25065,
                                GSE7390 = normalized_GSE7390))


# Density plot after batch effect correction
MakeDensityPlot(matrix = corbatch, 
                studies = list(GSE25055 = normalized_GSE25055, 
                               GSE11121 = normalized_GSE11121, 
                               GSE25065 = normalized_GSE25065,
                                GSE7390 = normalized_GSE7390))

# MDS plot before batch effect correction
# Important note : studies should match projname 
MakeMDSPlot(matrix = merge_studies, 
            studies = list(normalized_GSE25055, normalized_GSE11121, normalized_GSE25065, normalized_GSE7390), 
            projname = c("GSE25055", "GSE11121", "GSE25065", "GSE7390"), 
            compare = "grade",
            nstudies = 4)


# MDS plot after batch effect correction
# Important note : studies should match projname 
MakeMDSPlot(matrix = corbatch, 
            studies = list(normalized_GSE25055, normalized_GSE11121, normalized_GSE25065, normalized_GSE7390), 
            projname = c("GSE25055", "GSE11121", "GSE25065", "GSE7390"), 
            compare = "grade",
            nstudies = 4)

# Cohran Q test 
cohranqtest <- CochranQTest(studies = list(GSE11121, GSE25065, GSE25055, GSE7390),
                            groups = c("3", "1"),
                            compare = "grade")
# QQ plot of Cohran Q test 
MakeQQPlot(cohranq = cohranqtest, nstudies = 4)

FEMREMAnalysis(studies = list(normalized_GSE25055, normalized_GSE11121, normalized_GSE25065, normalized_GSE7390),
               projname = c("GSE25055", "GSE11121","GSE25065", "GSE7390"),
               compare = "grade",
               model = "REM",
               groups = c("3", "1"),
               FDR = 0.05,
               nperm = 50)


volcano_GSE11121 <- Makevolcano(projname = "GSE11121",
                                padjlevel = 0.05,
                                pSE_thresh = 1,
                                nSE_thresh = -1,
                                ntop = 10,
                                voltype = "ggplot")

volcano_GSE7390 <- Makevolcano(projname = "GSE7390",
                               padjlevel = 0.05,
                               pSE_thresh = 1,
                               nSE_thresh = -1,
                               ntop = 10,
                               voltype = "ggplot")

volcano_GSE25065 <- Makevolcano(projname = "GSE25065",
                                padjlevel = 0.05,
                                pSE_thresh = 1,
                                nSE_thresh = -1,
                                ntop = 10,
                                voltype = "ggplot")

volcano_GSE25055 <- Makevolcano(projname = "GSE25055",
                                padjlevel = 0.05,
                                pSE_thresh = 1,
                                nSE_thresh = -1,
                                ntop = 10,
                                voltype = "ggplot")
# Combination
volcano_combination <- Makevolcano(projname = "combination",
                                padjlevel = 0.05,
                                pSE_thresh = 1,
                                nSE_thresh = -1,
                                ntop = 10,
                                voltype = "ggplot")

MakeVenna(common = c("GSE25055", "GSE11121","GSE25065", "GSE7390"), ntop = 10)

MakeHeatmap(matrix = normalized_GSE25055,
            projname = "GSE25055",
            compare = "grade", 
            groups = list(grade1 = "1", grade3 = "3"),
            ntop = 25,
            sorted = FALSE)

MakeHeatmap(matrix = normalized_GSE11121,
            projname = "GSE11121",
            compare = "grade", 
            groups = list(grade1 = "1", grade3 = "3"),
            ntop = 25,
            sorted = FALSE)

MakeHeatmap(matrix = normalized_GSE25065,
            projname = "GSE25065",
            compare = "grade", 
            groups = list(grade1 = "1", grade3 = "3"),
            ntop = 25,
            sorted = FALSE)

MakeHeatmap(matrix = normalized_GSE7390,
            projname = "GSE7390",
            compare = "grade", 
            groups = list(grade1 = "1", grade3 = "3"),
            ntop = 25,
            sorted = FALSE)

# Combination 
MakeHeatmap(matrix = merge_studies,
            projname = "combination",
            compare = "grade", 
            groups = list(grade1 = "1", grade3 = "3"),
            ntop = 25,
            sorted = FALSE)
# Sorted grade
MakeHeatmap(matrix = merge_studies,
            projname = "combination",
            compare = "grade", 
            groups = list(grade1 = "1", grade3 = "3"),
            ntop = 25,
            sorted = TRUE)

GSEAAnalysis(projname = "GSE25055", FDR = 0.05)
GSEAAnalysis(projname = "GSE11121", FDR = 0.05)
GSEAAnalysis(projname = "GSE25065", FDR = 0.05)
GSEAAnalysis(projname = "GSE7390", FDR = 0.05)

# Combination
GSEAAnalysis(projname = "combination", FDR = 0.05)

Makenetworkanalyst(matrix = GSE11121,
                   projname = "GSE11121", 
                   compare = "grade", 
                   groups = list(grade1 = "1", grade3 = "3"))

Makenetworkanalyst(matrix = GSE25055,
                   projname = "GSE25055", 
                   compare = "grade", 
                   groups = list(grade1 = "1", grade3 = "3"))

Makenetworkanalyst(matrix = GSE25065,
                   projname = "GSE25065", 
                   compare = "grade", 
                   groups = list(grade1 = "1", grade3 = "3"))

Makenetworkanalyst(matrix = GSE7390,
                   projname = "GSE7390", 
                   compare = "grade", 
                   groups = list(grade1 = "1", grade3 = "3"))






		</code></pre>
	</div>


	<hr>
	
	
	<footer class="footer">
	    		<p>&copy; 2023 Mohammad Reza Mohajeri. All rights reserved.</p>
	</footer>
	
	<!-- JavaScript for Drop-down Functionality -->
	<script>
		function toggleDropDown(id) {
			var content = document.getElementById(id);
			content.classList.toggle("active");
		}
	</script>

</body>
</html>
